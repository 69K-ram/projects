<html>
  <style>
    /*  */
    html {
    height: 100%;
    margin: 0;
    }
    /* make the canvas fill its container */
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
  <div class="divcanvas">
  	<canvas id="canvas"></canvas>
	</div>
</html>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.addEventListener('mousedown', function(e) { 
	getCursorPosition(canvas, e) });

resizeCanvasToDisplaySize(canvas);

ctx.fillStyle = 'lightblue'; // paint canvas black
ctx.fillRect(0, 0, canvas.width, canvas.height);

cellSize = 25;
cellsWidth = Math.round(canvas.width / cellSize) + 2;
cellsTall  = Math.round(canvas.height / cellSize) + 2;

var cells = new Array(cellsWidth); // create cell array
for (let i = 0; i < cellsWidth; i++) {
  cells[i] = new Array(cellsTall);
}

let generations = 0;
clearCells(1);

let paused = false;

newGeneration();

function clearCells(random) {
	for (let y = 0; y < cellsTall; y++) { // initalize cell array
		for (let x = 0; x < cellsWidth; x++) {
			cells[x][y] = Math.max(Math.round(Math.random() - random), 0);
		}
	}
}

function newGeneration() {
	generations ++;
	//console.log(generations);
	let changedCells = cells;
	for (let y = 1; y < cellsTall - 1; y++) { // initalize cell array
		for (let x = 1; x < cellsWidth - 1; x++) {
			let neighbours = 0;
			// starts top left, checks clockwise
			neighbours += cells[x - 1][y - 1];
			neighbours += cells[x]		[y - 1];
			neighbours += cells[x + 1][y - 1];
			neighbours += cells[x + 1][y];
			neighbours += cells[x + 1][y + 1];
			neighbours += cells[x]    [y + 1];
			neighbours += cells[x - 1][y + 1];
			neighbours += cells[x - 1][y];

			if (cells[x][y] == 1) { // live cell
				if (neighbours <= 1 || neighbours > 3) {
					changedCells[x][y] = 0;
				}
			} else { // dead cell
				if (neighbours == 3) {
					changedCells[x][y] = 1; // cell revives
				};
			};

		};
	
	};
	cells = changedCells;
	displayCells();

	if (paused == false) { 
		let callID = setTimeout(newGeneration, 1000);
	} else {
		clearTimeout(callID);
	}
}

function displayCells() {
	for (let y = 1; y < cellsTall - 1; y++) { // initalize cell array
		for (let x = 1; x < cellsWidth - 1; x++) {
			
			// assume cell is empty, draw empty
			ctx.fillStyle = 'black';
			ctx.fillRect((x - 1) * cellSize, (y - 1) * cellSize, cellSize, cellSize);
			
			// if cell is alive, draw black
			if (cells[x][y] == 1 ){
				ctx.fillStyle = 'white';
				ctx.fillRect((x - 1) * cellSize, (y - 1) * cellSize, cellSize, cellSize);
			}
			
		}
	}
	
	ctx.font = "30px Comic Sans MS";

	ctx.fillStyle = "blue";
	ctx.fillText("Clear", 85, 30);

	ctx.fillStyle = "purple";
	ctx.fillText("Random", 165, 30);

	if (paused == false){
		ctx.fillStyle = "red";
		ctx.fillText("Pause", 5, 30);
	
	} else {
		ctx.fillStyle = "green";
		ctx.fillText("Play", 5, 30);
	}
	
}

function resizeCanvasToDisplaySize(canvas) {
  // Lookup the size the browser is displaying the canvas in CSS pixels.
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;
  // Check if the canvas is not the same size.
  const needResize = canvas.width  !== displayWidth || canvas.height !== displayHeight;
  if (needResize) {
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
	return needResize;
}

function getCursorPosition(canvas, event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    cellX = Math.round(x / cellSize) + 1;
    cellY = Math.round(y / cellSize) + 1;

    if (x < 70 && y < 50) {
    	if (paused == true) {
    		paused = !paused;
    		newGeneration();
    	} else { paused = !paused;}
    	
    }	else {
    	cells[cellX][cellY] = 1 - cells[cellX][cellY];
    }

    displayCells();
  	
}

</script>
